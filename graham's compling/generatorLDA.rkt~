#lang racket

(define my-corpus '((broccoli is good)
                    (green onion is good)
                    (meat and cheese is good)))

(define vocabulary '(broccoli is good green onion meat and cheese))


(define topic1 (list (/ 1 8 ) (/ 1 8 ) (/ 1 8 ) (/ 1 8 ) (/ 1 8 ) (/ 1 8 ) (/ 1 8 ) (/ 1 8 ))) ; distribution over the words
(define topic2 (list (/ 1 8 ) (/ 1 16) (/ 3 16 ) (/ 1 8 ) (/ 1 8 ) (/ 1 8 ) (/ 1 8 ) (/ 1 8 )))
(define topics (list topic1 topic2)) ;think of this as a vector which assigns prob 0 to all other word distributions

; distribution over topic distributions. one per document

(define theta-prior1 (list (/ 1 8) (/ 7 8))) ; assigned to topic1 and topic2 (and 0 to all other topics)
(define theta-prior2 (list (/ 1 2) (/ 1 2))) ; theta-prior1 and theta-prior2 are distributions over the topics

; allows us to pick which topics a document focuses on
; we parametrize this simplex by focusing on topics whose distributions are closer to a realistic topic
(define theta-priors (list theta-prior1 theta-prior2)) ;think of this as a simplex which puts weight on these two distributions over topics
(define topics-distribution (list (/ 1 4) (/ 3 4)))


(define (sample-document vocab topics theta-prior length)
  (if (equal? length 0)
      '()
      (cons (sample-categorical vocab (sample-categorical topics theta-prior))
            (sample-document vocab topics theta-prior (- length 1)))))

(define (sample-document-fake-LDA vocab topics topics-distribution theta-priors length)
  (let ((theta-prior (sample-categorical theta-priors topics-distribution))) ;distribution over topics
    (sample-document vocab topics theta-prior length)))

; generate 5 documents
(repeat (lambda () (sample-document-fake-LDA vocabulary topics topics-distribution theta-priors 20)) 5)

(define (score-categorical outcome outcomes params)
  (if (null? params)
      (error "no matching outcome")
      (if (equal? outcome (car outcomes))
          (car params)
          (score-categorical outcome (cdr outcomes) (cdr params)))))

(define (gibbs-sampler-single document vocab topics topics-distribution)
  (let* ((topic-assignments (map (lambda () (sample-categorical topics topics-distribution)) document))
         topic-frequencies ((map (lambda (topic) (count topic topic-assignments))) topics))
    (map ())
  )
  
(define (list-foldr f base lst)
  (if (null? lst)
      base
      (f (car lst)
         (list-foldr f base (cdr lst)))))

(define (score-BOW-sentence sen probabilities)
  (list-foldr 
   (lambda (word rest-score)
     (+ (log (score-categorical word vocabulary probabilities))
        rest-score))
   0
   sen))


(define (score-corpus corpus probabilities)
  (list-foldr
   (lambda (sen rst)
     (+ (score-BOW-sentence sen probabilities) rst))
   0
   corpus))

(define (logsumexp log-vals)
  (let ((mx (apply max log-vals)))
    (+ mx
       (log
           (apply +
                  (map exp
                       (map (lambda (x) (- x mx)) log-vals)))))))

(define (normalize params)
  (let ((sum (apply + params)))
    (map (lambda (x) (/ x sum)) params)))

(define (flip p)
  (if (< (random 100) (* p 100))
      #t
      #f))

(define (sample-categorical outcomes params)
  (if (flip (car params))
      (car outcomes)
      (sample-categorical (cdr outcomes) 
                          (normalize (cdr params)))))

(define (repeat f n)
  (if (= n 0)
      '()
      (cons (f) (repeat f (- n 1)))))

(define (sample-BOW-sentence theta len)
    (if (= len 0)
        '()
        (cons (sample-categorical vocabulary theta)
              (sample-BOW-sentence theta (- len 1)))))



(define (get-count obs observation-list count)
  (if (equal? observation-list '())
      count
      (if (equal? obs (car observation-list))
          (get-count obs (cdr observation-list) (+ 1 count))
          (get-count obs (cdr observation-list) count))))


(define (get-counts outcomes observation-list)
  (define (count-obs obs)
    (get-count obs observation-list 0))
  (map count-obs outcomes))


; Tim's code for dirichlet
(define (sample-gamma shape scale)
  (apply + (repeat shape (lambda () (- (log (random)))))))

(define (sample-dirichlet pseudos)
  (let ((gammas (map (lambda (sh)
                       (sample-gamma sh 1))
                     pseudos)))
    (normalize gammas)))

(define gamma
  (let ((a (reverse
             '(1.00000000000000000000  0.57721566490153286061 
               -0.65587807152025388108 -0.04200263503409523553  
               0.16653861138229148950 -0.04219773455554433675
               -0.00962197152787697356  0.00721894324666309954 
               -0.00116516759185906511 -0.00021524167411495097  
               0.00012805028238811619 -0.00002013485478078824
               -0.00000125049348214267  0.00000113302723198170 
               -0.00000020563384169776 0.00000000611609510448  
               0.00000000500200764447 -0.00000000118127457049
               0.00000000010434267117 0.00000000000778226344 
               -0.00000000000369680562 0.00000000000051003703 
               -0.00000000000002058326 -0.00000000000000534812
               0.00000000000000122678 -0.00000000000000011813  
               0.00000000000000000119 0.00000000000000000141 
               -0.00000000000000000023  0.00000000000000000002))))
    (lambda (x)
      (let ((y (- x 1)))
        (do ((as a (cdr as))
             (res 0 (+ (car as) (* res y))))
          ((null? as) (/ 1 res)))))))


(define (score-dirichlet thetas pseudos)
 (+ (log (/ (gamma (apply + pseudos))
            (apply * (map gamma pseudos))))
    (apply + (map (lambda (theta pseudo)
                    (* (log theta) pseudo))
                  thetas pseudos))))
(exp (score-dirichlet (list (/ 1 3) (/ 1 3) (/ 1 3)) '(1 1 1)))
